<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="utf-8">
    <title>Cyber Formula Mini Race</title>
    <meta name="viewport" content="width=device-width, initial-scale=0.5, maximum-scale=0.5, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&family=Orbitron:wght@900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background: #2a2a2a; overflow: hidden; font-family: Rajdhani, sans-serif; color: #fff; }
        canvas#game { display: block; background: transparent; margin: 20px auto; border: 3px solid #333; z-index: 1; }
		
		/* 1. 改為藍天背景 */
		#titleScreen {
			position: fixed;
			inset: 0;
			/* 晴朗藍天漸層：從上方較深的藍到下方較亮的天藍 */
			background: linear-gradient(to bottom, #1e5799 0%, #2989d8 50%, #7db9e8 100%);
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			z-index: 999;
		}
		@keyframes gradientBG {
			0% { background-position: 0% 50%; }
			50% { background-position: 100% 50%; }
			100% { background-position: 0% 50%; }
		}

		/* 2. 新增 Logo 圖片樣式 (手機適用) */
		#titleLogo {
			/* 確保在大螢幕上不會超過原始尺寸太多 */
			max-width: 600px; 
			/* 關鍵：在小螢幕 (手機) 上，寬度最多佔 90%，高度自動維持比例 */
			width: 90%;
			height: auto;
			
			margin-bottom: 10px;
			/* 加上一點點浮起的陰影，讓 Logo 更有立體感 */
			filter: drop-shadow(0px 8px 15px rgba(0, 0, 0, 0.4));
			
			/* 進場動畫 (選用)：從上方滑入 */
			animation: slideDown 0.8s ease-out;
		}

		@keyframes slideDown {
			from { transform: translateY(-100px); opacity: 0; }
			to { transform: translateY(0); opacity: 1; }
		}

		/* 3. 調整副標題樣式以配合藍天背景 */
		#titleScreen h2 {
			font-family: 'Rajdhani', sans-serif;
			font-size: 50px;
			/* 改為白色文字 */
			color: #ffffff;
			margin: 0 0 40px 0;
			letter-spacing: 8px;
			/* 改用深藍色描邊效果，而非霓虹發光，更像遊戲介面 */
			text-shadow: 
				3px 3px 0px #003366, 
				-3px -3px 0px #003366,
				3px -3px 0px #003366,
				-3px 3px 0px #003366;
			font-weight: 700;
		}


		#titleScreen h2 { 
			font-family: 'Rajdhani', sans-serif; font-size: 60px; color: #00ffea; 
			text-shadow: 0 0 20px #00ffea; margin-top: -10px; letter-spacing: 10px; 
		}

       
       
        #checkered { width: 600px; height: 140px; display: grid; grid-template-columns: repeat(15, 1fr); grid-template-rows: repeat(4, 1fr); border: 8px solid #fff; box-shadow: 0 0 50px rgba(255,255,255,0.8); margin: 50px 0; }
        #checkered div { width: 100%; height: 100%; background: #000; }
        #checkered div:nth-child(odd) { background: #fff; }
        #checkered div:nth-child(even) { background: #000; }
        
        #startTitleBtn { background: linear-gradient(45deg, #ff1b6b, #ff8c00); color: #fff; padding: 25px 90px; font-size: 48px; border: none; border-radius: 60px; cursor: pointer; transition: 0.4s; box-shadow: 0 15px 40px rgba(255,27,107,0.5); font-weight: 700; letter-spacing: 5px; }
        #startTitleBtn:hover { transform: scale(1.1); }
        
        #finishScreen { position: fixed; inset: 0; background: rgba(0,0,0,0.95); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 999; }
        #finishScreen h1 { font-family: Orbitron, sans-serif; font-size: 120px; color: #00ff41; text-shadow: 0 0 50px #00ff41; }
        #finalPos { font-size: 60px; margin: 30px 0; text-shadow: 0 0 30px #fff; }
        #backToMenuBtn { background: #00ff41; color: #000; padding: 25px 100px; font-size: 45px; border: none; border-radius: 60px; cursor: pointer; font-weight: 700; }
        
        #gameContainer { position: relative; width: 1000px; height: 1600px; margin: 20px auto; }
        canvas { z-index: 1; }
        #hud, #lapHud, #posHud, #speedHud, #countdown { z-index: 10; position: absolute; font-weight: bold; }
		
		/* 隱藏舊的文字 HUD，準備用 Canvas 畫 */
		#speedHud { display: none; } 
		
		/* 新增儀表板 Canvas */
		#dashboardCanvas {
			position: absolute;
			bottom: 330px;
			right: 30px;
			z-index: 20;
			background: transparent; 
			pointer-events: none; 
		}
		
        #hud { top: 20px; left: 20px; background: rgba(0,0,0,0.7); padding: 10px 20px; border-radius: 12px; font: 22px Arial; }
        #lapHud { top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 12px 35px; border-radius: 12px; font: 32px Arial; }
        #posHud { top: 20px; right: 20px; background: rgba(0,0,0,0.7); padding: 10px 25px; border-radius: 12px; font: 26px Arial; }
        #speedHud { bottom: 240px; right: 30px; background: rgba(255,0,0,0.8); padding: 20px 40px; border-radius: 25px; font: 60px bold Arial; text-shadow: 0 0 20px #ff0000; }
        #countdown { top: 50%; left: 50%; transform: translate(-50%,-50%); font: 220px bold Arial; color: #ff0044; display: none; text-shadow: 0 0 60px #ff0000; }
        
        .menu { display: none; position: fixed; inset: 0; background: #000; flex-direction: column; align-items: center; overflow-y: auto; z-index: 99; padding: 40px 20px 120px; }
        .menu.active { display: flex; }
        .menu h1 { font-family: Orbitron, sans-serif; font-size: 70px; margin: 20px 0; text-shadow: 0 0 30px #00ffff; }
        
		/* 4. 菜單畫面 (Mode Select) 視覺修正 */
				#mainMenu.menu {
					/* 覆寫 .menu 的背景為藍天漸層 */
					background: linear-gradient(to bottom, #1e5799 0%, #2989d8 50%, #7db9e8 100%);
					justify-content: center; /* 讓內容垂直居中 */
				}

				/* 複製 #titleLogo 樣式給菜單 Logo */
				.menu-logo {
					max-width: 600px; 
					width: 90%;
					height: auto;
					margin-bottom: 20px; /* 增加與標題的間距 */
					filter: drop-shadow(0px 8px 15px rgba(0, 0, 0, 0.4));
				}
				
				/* 調整 #mainMenu 標題樣式 */
				#mainMenu h1 { 
					/* 使用類似 Title Screen 副標題的樣式 */
					font-family: 'Rajdhani', sans-serif;
					font-size: 50px;
					color: #ffffff;
					margin: 0 0 40px 0;
					letter-spacing: 8px;
					text-shadow: 
						3px 3px 0px #003366, 
						-3px -3px 0px #003366,
						3px -3px 0px #003366,
						-3px 3px 0px #003366;
					font-weight: 700;
				}

				.btn { background: linear-gradient(45deg, #667eea, #764ba2); padding: 18px 50px; margin: 15px; font-size: 36px; border: none; border-radius: 15px; cursor: pointer; width: 80%; max-width: 500px; transition: 0.3s; box-shadow: 0 10px 30px rgba(102,126,234,0.4); }
				.btn:hover { transform: scale(1.05); box-shadow: 0 15px 40px rgba(102,126,234,0.6); }
        
        /* Track Select */
        #trackSelect .track-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 25px; width: 100%; max-width: 1000px; margin: 30px 0; }
        .track-card { background: #111; padding: 20px; border-radius: 15px; cursor: pointer; transition: 0.3s; border: 4px solid transparent; text-align: center; }
        .track-card:hover { transform: scale(1.05); background: #222; }
        .track-card.selected { border: 4px solid #00ff41; background: #003300 !important; }
        .track-card img { width: 100%; max-height: 50vh; object-fit: contain; border-radius: 10px; }
        
        /* Car Select */
        #carMenu .container { max-width: 1000px; width: 95%; padding: 20px 0; }
        #carList { display: block; width: 100%; max-width: 1000px; margin: 30px auto; } /* 替換為 block 容器以便容納標題和列表 */
        
        /* 新增：車隊標題樣式 */
        .team-header {
          font-family: 'Orbitron', sans-serif;
          font-size: 30px;
          color: #00ffea;
          text-shadow: 0 0 10px #00ffea;
          margin: 30px 0 15px;
          border-bottom: 2px solid rgba(0,255,234,0.3);
          padding-bottom: 5px;
          text-align: left;
        }

        /* 新增：車輛列表容器樣式 (代替 #carList 內部的 grid) */
        .car-list-container {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
          gap: 20px;
          list-style: none;
          padding: 0;
          margin: 0;
        }

        /* 使用 li 代替原來的 .card div，並繼承樣式 */
        .car-list-container li {
          background: #222;
          padding: 10px;
          border-radius: 15px;
          cursor: pointer;
          transition: 0.3s;
          border: 4px solid transparent;
          text-align: center;
        }

        .car-list-container li:hover { 
          transform: scale(1.05); 
          background: #333; 
        }

        .car-list-container li.selected { 
          border: 4px solid #0f0; 
          background: #003300 !important; 
        }

        .car-list-container img {
          width: 100%;
          max-height: 100px; 
          object-fit: contain;
        }
        
        /* Mobile Controls: 修正方向鍵位置和樣式 (恢復圓形、置於角落) */
		#mobileControls {
		  position: fixed;
		  bottom: 0; 
		  left: 0;
		  width: 100%; 
		  height: 300px; 
		  pointer-events: none; 
		  z-index: 999;
		}

		#moveVertical, #moveHorizontal {
		  position: absolute; 
		  display: flex;
		  gap: 10px; 
		  pointer-events: auto;
		}

		#moveVertical {
		  left: 20px;
		  bottom: 80px;
		  flex-direction: column;
		}

		#moveHorizontal {
		  right: 20px;
		  bottom: 120px;
		  flex-direction: row;
		}

		#mobileControls button {
		  width: 120px;  /* 調整為圓形大小 */
		  height: 120px;
		  border-radius: 50%; /* **改回圓形** */
		  border: 2px solid #fff;
		  background: rgba(0,0,0,0.6);
		  font-size: 40px; 
		  color: #fff;
		  box-shadow: 0 5px 15px rgba(0,0,0,0.7);
		}

		#mobileControls button:active {
		  transform: scale(0.9);
		}

    </style>
</head>
<body>
    <div id="titleScreen">
        <img id="titleLogo" src="Cyber_Formula.png" alt="Cyber Formula Logo">
        <h2>MINI RACE</h2>
        <div id="checkered">
            </div>
        <button id="startTitleBtn">START</button>
    </div>
    
    <div id="finishScreen">
        <h1>FINISH!</h1>
        <p id="finalPos">FINAL POS #1</p>
        <button id="backToMenuBtn">BACK TO MENU</button>
    </div>
    
    <div id="mainMenu" class="menu">
		<img class="menu-logo" src="Cyber_Formula.png" alt="Cyber Formula Logo">
        <h1>MODE SELECT</h1>
        <button class="btn" id="champBtn">CHAMPIONSHIP MODE</button>
        <button class="btn" id="timeBtn">FREE RUN</button>
    </div>
    
    <div id="trackSelect" class="menu">
        <h1>TRACK SELECT</h1>
        <div class="track-grid" id="trackGrid"></div>
        <button class="btn" id="confirmTrackBtn">CONFIRM</button>
    </div>
    
    <div id="carMenu" class="menu">
        <h1>FORMULA SELECT</h1>
        <div class="container">
            <div id="carList"></div>
        </div>
        <button class="btn" id="confirmBtn">CONFIRM</button>
    </div>
    
    <div id="gameContainer">
        <canvas id="game" width="1000" height="1600"></canvas>
        <div id="hud"></div>
        <div id="lapHud">LAP 0/3</div>
        <div id="posHud">POS #1/11</div>
        <div id="speedHud">0 kmh</div>
        <div id="countdown"></div>
		<canvas id="dashboardCanvas" width="400" height="250"></canvas>
    </div>
    
	 <div id="mobileControls">
	  <div id="moveVertical">
		<button id="btnUp">↑</button>
		<button id="btnDown">↓</button>
	  </div>
	  <div id="moveHorizontal">
		<button id="btnLeft">←</button>
		<button id="btnRight">→</button>
	  </div>
	</div>


    <script src="cars.js"></script>
    <script src="track.js"></script>
    <script>
        const SCALE = 5;
        const CARWIDTH = 90;
        const CARHEIGHT = 150;
        
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
		
		// 新增儀表板 Context
		const dashCanvas = document.getElementById('dashboardCanvas');
		const dashCtx = dashCanvas.getContext('2d');
		
        
        let player = null, allCars = [], gameState = 'title', mode = '', countdown = 0;
        let selectedCar = 0, playerCarImg = new Image(), trackImg = null;
        let keys = {}, touch = {}, lap = 0, totalLaps = 3, raceFinished = false, currentTrack = 0;
        let boostParticles = []; // 加速特效粒子
		
		// 在 init 或 script 開頭加入這個變數
		let sandPattern = null;
		
		// 新增一個函數：預先產生沙地材質 (只執行一次，效能更好)
		function createSandPattern() {
			const pCanvas = document.createElement('canvas');
			pCanvas.width = 64;
			pCanvas.height = 64;
			const pCtx = pCanvas.getContext('2d');

			// 1. 填滿底色 (不透明)
			pCtx.fillStyle = '#C2B280'; // 沙色
			pCtx.fillRect(0, 0, 64, 64);

			// 2. 畫雜點 (SFC 風格)
			pCtx.fillStyle = '#B0A070'; // 深一點的沙色
			for(let i=0; i<40; i++) {
				pCtx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
			}
			pCtx.fillStyle = '#D6C690'; // 淺一點的沙色
			for(let i=0; i<40; i++) {
				pCtx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
			}

			return ctx.createPattern(pCanvas, 'repeat');
		}
		
		
		// 1. 視覺升級：繪製沙地背景 (替代原本的單色背景)
		function drawSandBackground(ctx, offsetX, offsetY) {
			const patternSize = 100;
			ctx.save();
			ctx.fillStyle = '#C2B280'; // 沙地底色
			ctx.fillRect(0, 0, W, H);
			
			// 畫一點雜點質感
			ctx.fillStyle = 'rgba(160, 140, 80, 0.3)';
			for (let i=0; i<W; i+=50) {
				for (let j=0; j<H; j+=50) {
					// 根據位置偏移製造流動感，或者固定紋理
					if ((i+j)%100 === 0) ctx.fillRect(i, j, 50, 50);
				}
			}
			ctx.restore();
		}

		// 2. 視覺升級：改進的賽道繪製 (加入紅白路緣石)
		function drawCurrentTrackRoad(ctx, offsetX, offsetY) {
			const t = TRACKS[currentTrack];
			const wps = t.waypoints;
			if (!wps || !wps.length) return;

			ctx.save();
			ctx.lineJoin = 'round';
			ctx.lineCap = 'round'; // 轉彎處圓滑

			// 建立路徑 (只做一次路徑，重複描邊)
			ctx.beginPath();
			ctx.moveTo(wps[0].x * SCALE - offsetX, wps[0].y * SCALE - offsetY);
			for (let i = 1; i < wps.length; i++) {
				ctx.lineTo(wps[i].x * SCALE - offsetX, wps[i].y * SCALE - offsetY);
			}
			ctx.closePath();

			// --- 第一層：路緣石底色 (紅色) ---
			// 寬度設為 700，比路面寬很多
			ctx.lineWidth = 700; 
			ctx.strokeStyle = '#d32f2f'; // 賽車紅
			ctx.stroke();

			// --- 第二層：路緣石相間色 (白色) ---
			// 寬度一樣 700，但用虛線覆蓋
			ctx.lineWidth = 700;
			ctx.strokeStyle = '#ffffff';
			ctx.setLineDash([50, 50]); // 50px實線, 50px空白
			ctx.lineDashOffset = -Date.now() / 20; // (選用) 讓路緣石有速度感的流動特效！如果不想要流動，刪除這行
			ctx.stroke();
			
			ctx.setLineDash([]); // 重置虛線

			// --- 第三層：柏油路面 (灰色) ---
			// 寬度設為 550，這樣左右各會露出 (700-550)/2 = 75px 的路緣石
			ctx.lineWidth = 550;
			ctx.strokeStyle = '#555555'; // 深灰路面
			ctx.stroke();

			// --- 第四層：中央分隔線 ---
			ctx.lineWidth = 6;
			ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
			ctx.setLineDash([80, 100]);
			ctx.stroke();
			
			ctx.restore();
		}

		// 3. HUD 升級：繪製類比儀表板
		function drawDashboard(speed) {
			const w = dashCanvas.width;
			const h = dashCanvas.height;
			const cx = w / 2;
			const cy = h - 20;
			const radius = 160;

			// 1. 重要：完全清除畫布，保持透明背景
			dashCtx.clearRect(0, 0, w, h);

			const startAngle = Math.PI;       // 180度 (左)
			const endAngle = Math.PI * 2;     // 360度 (右)
			const maxSpeed = 30; 
			const speedPct = Math.min(Math.abs(speed), maxSpeed) / maxSpeed;
			const currentAngle = startAngle + (endAngle - startAngle) * speedPct;

			// 2. 畫儀表背板 (半透明黑色弧形，而非矩形)
			dashCtx.beginPath();
			dashCtx.arc(cx, cy, radius, startAngle, endAngle);
			dashCtx.lineWidth = 40;
			dashCtx.strokeStyle = 'rgba(0, 0, 0, 0.5)'; // 只有刻度條後面有半透明黑
			dashCtx.stroke();

			// 3. 畫顏色漸層條
			const grad = dashCtx.createLinearGradient(0, 0, w, 0);
			grad.addColorStop(0.2, '#00ff00');
			grad.addColorStop(0.6, '#ffff00');
			grad.addColorStop(1.0, '#ff0000');

			dashCtx.beginPath();
			dashCtx.arc(cx, cy, radius, startAngle, endAngle);
			dashCtx.lineWidth = 20;
			dashCtx.lineCap = 'butt';
			dashCtx.strokeStyle = 'rgba(255,255,255,0.1)'; // 未亮起的底色
			dashCtx.stroke();

			// 亮起的部分
			dashCtx.beginPath();
			dashCtx.arc(cx, cy, radius, startAngle, currentAngle);
			dashCtx.lineWidth = 20;
			dashCtx.strokeStyle = grad;
			dashCtx.stroke();

			// 4. 畫指針 (更銳利)
			dashCtx.save();
			dashCtx.translate(cx, cy);
			dashCtx.rotate(currentAngle);
			
			dashCtx.beginPath();
			dashCtx.moveTo(0, 0);
			dashCtx.lineTo(radius + 10, 0); // 指針稍微凸出一點
			dashCtx.lineWidth = 4;
			dashCtx.strokeStyle = '#fff';
			dashCtx.shadowBlur = 10;
			dashCtx.shadowColor = '#fff';
			dashCtx.stroke();
			dashCtx.restore();

			// 5. 數字速度 (科幻字體)
			dashCtx.font = 'italic bold 60px Orbitron';
			dashCtx.fillStyle = '#fff';
			dashCtx.textAlign = 'center';
			dashCtx.shadowBlur = 15;
			dashCtx.shadowColor = '#00ffff';
			const kmh = Math.round(Math.abs(speed) * 20);
			dashCtx.fillText(kmh, cx, cy - 50);
			
			dashCtx.font = '20px Rajdhani';
			dashCtx.fillStyle = '#aaa';
			dashCtx.shadowBlur = 0;
			dashCtx.fillText("KM/H", cx, cy - 25);
		}
		
		
        
        // 碰撞檢測函數
		function checkCollisions(car1, car2) {
		  const dx = car2.x - car1.x;
		  const dy = car2.y - car1.y;
		  const dist = Math.hypot(dx, dy);
		  const minDist = (CARWIDTH + CARHEIGHT) / 3;

		  if (dist < minDist) {
			const push = (minDist - dist) * 0.4;
			const nx = dx / (dist || 1);
			const ny = dy / (dist || 1);

			car1.x -= nx * push;
			car1.y -= ny * push;
			car2.x += nx * push;
			car2.y += ny * push;

			// 只係略略衰減速度，唔交換
			car1.speed *= 0.9;
			car2.speed *= 0.9;
		  }
		}

        
        // 改進的AI超車邏輯
		function followWaypoints(car) {
		  if (car.waypointIndex == null) car.waypointIndex = 0;
		  const wp = TRACKS[currentTrack].waypoints;
		  if (!wp.length) return;

		  const baseTarget = wp[car.waypointIndex];
		  let tx = baseTarget.x * SCALE;
		  let ty = baseTarget.y * SCALE;

		  const nextIndex = (car.waypointIndex + 1) % wp.length;
		  const nx = wp[nextIndex].x * SCALE;
		  const ny = wp[nextIndex].y * SCALE;
		  let dirX = nx - tx;
		  let dirY = ny - ty;
		  const len = Math.hypot(dirX, dirY) || 1;
		  dirX /= len; dirY /= len;
		  const nX = -dirY;
		  const nY = dirX;

		  const baseOffset = car.laneOffset || 0;
		  tx += nX * baseOffset;
		  ty += nY * baseOffset;

		  // --- 1. 找前車 ---
		  let frontCar = null;
		  let minDist = Infinity;
		  const candidates = [...allCars, player].filter(c => c !== car);
		  candidates.forEach(other => {
			const dx = other.x - car.x;
			const dy = other.y - car.y;
			const dist = Math.hypot(dx, dy);
			const rel = dx * dirX + dy * dirY;   // 前後
			if (rel > 0 && dist < 260 && dist < minDist) {
			  minDist = dist;
			  frontCar = other;
			}
		  });

		  // --- 2. 決定有冇進入 overtake 模式 ---
		  const wantOvertake = frontCar &&
			minDist < 260 &&                    // 幾近
			car.speed > (frontCar.speed || 0) + 2;  // 明顯快過前面

		  if (car.overtakeTimer <= 0 && wantOvertake) {
			// 開始一個 1~2 秒嘅超車窗口
			car.overtakeTimer = 60 + Math.random() * 60;
			const sideRaw = Math.sign((frontCar.x - car.x) * nX + (frontCar.y - car.y) * nY);
			car.overtakeSide = sideRaw === 0 ? (Math.random() < 0.5 ? -1 : 1) : sideRaw;
		  }

		  if (car.overtakeTimer > 0) {
			car.overtakeTimer--;
		  } else {
			car.overtakeSide = 0;
		  }

		  // --- 3. 計最終 offset ---
		  let dynamicOffset = 0;
		  if (car.overtakeSide !== 0) {
			dynamicOffset = car.overtakeSide * 120;  // 真正出線
		  } else if (frontCar && minDist < 150) {
			// 冇正式超車，只係避一避
			const side = Math.sign((frontCar.x - car.x) * nX + (frontCar.y - car.y) * nY) || 1;
			dynamicOffset = side * 40;
		  }

		  const targetX = tx + nX * dynamicOffset;
		  const targetY = ty + nY * dynamicOffset;

		  const dx = targetX - car.x;
		  const dy = targetY - car.y;
		  const distToWp = Math.hypot(dx, dy);
		  if (distToWp < 500) {
			car.waypointIndex = (car.waypointIndex + 1) % wp.length;
		  }

		  const targetAngle = Math.atan2(dy, dx);
		  let angleDiff = targetAngle - car.angle;
		  angleDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));
		  car.angle += angleDiff * 0.18;

		  // --- 4. 速度控制，用 speedFactor 拉開實力 ---
		  const sf = car.speedFactor || 1;
		  const maxSpeedBase = (23 + Math.random() * 4) * sf;

		  if (frontCar && minDist < 120 && car.overtakeSide === 0) {
			// 未出線之前，跟車少少
			car.speed += car.spec.acceleration * 0.03;
			car.speed = Math.min(car.speed, maxSpeedBase * 0.5);
		  } else {
			// 正常 / 超車
			car.speed += car.spec.acceleration * 0.06;
			car.speed = Math.min(car.speed, maxSpeedBase);
		  }
		  car.speed *= 0.985;

		  car.x += Math.cos(car.angle) * car.speed;
		  car.y += Math.sin(car.angle) * car.speed;
		}


        
        function loadTrack(i) {
            currentTrack = i;
            trackImg = new Image();
            trackImg.onload = () => {
                document.getElementById('hud').textContent = `TRACK: ${TRACKS[i].name}`;
            };
            trackImg.src = TRACKS[i].bgImage;
        }
        
        function openTrackSelect(m) {
            mode = m;
            document.getElementById('mainMenu').classList.remove('active');
            document.getElementById('trackSelect').classList.add('active');
            const grid = document.getElementById('trackGrid');
            grid.innerHTML = '';
            TRACKS.forEach((t, i) => {
                const d = document.createElement('div');
                d.className = `track-card ${i === currentTrack ? 'selected' : ''}`;
                d.innerHTML = `<img src="${t.bgImage}"><br>${t.name}`;
                d.onclick = () => {
                    currentTrack = i;
                    grid.querySelectorAll('.track-card').forEach(c => c.classList.remove('selected'));
                    d.classList.add('selected');
                    loadTrack(i);
                };
                grid.appendChild(d);
            });
        }

		// **【修正後的 buildCarList 邏輯】**
		function buildCarList() {
			const container = document.getElementById('carList'); 
			container.innerHTML = ''; 

			// 1. 按車隊分組
			const teams = {};
			CARSPECS.forEach((spec, index) => {
				// 修正：使用 [^/] 匹配任何非斜線的字符，以確保可以捕獲包含空格的資料夾名稱 (如 UNION SAVIOR)
				const teamNameMatch = spec.image.match(/^([^/]+)\//); 
				
				// 由於您要求移除 'Others'，我們假設所有路徑都應包含資料夾名稱
				let teamName = teamNameMatch ? teamNameMatch[1] : 'ERROR_NO_FOLDER'; 
				
				// 處理多字元隊名並首字母大寫
				// 步驟1: 將底線和連字符替換成空格
				teamName = teamName.replace(/[-_]/g, ' '); 
				// 步驟2: 將所有單詞的首字母大寫，並將其餘字母轉為小寫
				teamName = teamName.split(' ').map(word => 
					 word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
				).join(' ');

				if (!teams[teamName]) {
					teams[teamName] = [];
				}
				teams[teamName].push({ ...spec, index: index });
			});

			// 2. 遍歷分組並生成 HTML 結構
			Object.keys(teams).sort().forEach(teamName => { // 加上 .sort() 讓車隊按字母排序
				
				// 確保不顯示任何錯誤分類
				if (teamName === 'Error No Folder') return; 

				const carsInTeam = teams[teamName];

				// 創建車隊標題
				const header = document.createElement('div');
				header.className = 'team-header';
				header.textContent = teamName + ' Team';
				container.appendChild(header);

				// 創建車輛列表容器
				const ul = document.createElement('ul');
				ul.className = 'car-list-container';

				carsInTeam.forEach(car => {
					const li = document.createElement('li');
					li.className = `card ${car.index === selectedCar ? 'selected' : ''}`;
					li.setAttribute('data-index', car.index);

					// 圖像元素
					const img = document.createElement('img');
					img.src = car.image;
					img.alt = car.image;

					// 簡單的車名顯示
					const baseName = car.image.split('/').pop().replace('.png', '').replace(/_/g, ' ');
					const carName = document.createElement('p');
					carName.textContent = baseName;
					carName.style.fontSize = '12px';
					carName.style.margin = '5px 0 0';
					carName.style.color = '#ccc';
					carName.style.fontFamily = 'Rajdhani, sans-serif';

					li.appendChild(img);
					li.appendChild(carName);

					// 處理選中狀態的點擊事件
					li.onclick = () => {
						const selectedIndex = parseInt(li.getAttribute('data-index'));
						selectedCar = selectedIndex;

						// 更新所有車輛的選中狀態
						document.querySelectorAll('#carMenu .card').forEach(item => {
							item.classList.remove('selected');
						});
						li.classList.add('selected');
					};

					ul.appendChild(li);
				});

				container.appendChild(ul);
			});
		}
		// **【修正後的 buildCarList 邏輯 結束】**

        
        function startRace() {
            allCars = [];
            const t = TRACKS[currentTrack];
            if (mode === 'championship') {
                const a = CARSPECS.map((_, i) => i).filter(i => i !== selectedCar);
                const chosen = [];
                while (chosen.length < 10 && a.length > 0) {
                    chosen.push(a.splice(Math.floor(Math.random() * a.length), 1)[0]);
                }
                chosen.forEach((idx, i) => {
                    const img = new Image();
                    img.src = CARSPECS[idx].image;
                    const p = t.gridPositions[i];
					allCars.push({
					  x: p.x * SCALE,
					  y: p.y * SCALE,
					  angle: t.playerStart.angle,   // 用返你現時角度
					  speed: 0,
					  spec: CARSPECS[idx],
					  img: img,
					  waypointIndex: 0,
					  overtakeTimer: 0,
					  overtakeSide: 0,
					  laneOffset: (i % 2 === 0 ? -60 : 60),
					  speedFactor: 0.9 + Math.random() * 0.3  // 0.9~1.2 之間
					});
                });
            }
            player = {
                x: t.playerStart.x * SCALE, y: t.playerStart.y * SCALE,
                angle: t.playerStart.angle , speed: 0,
                spec: CARSPECS[selectedCar], img: playerCarImg
            };
            countdown = 5;
            gameState = 'countdown';
            lap = 0;
            raceFinished = false;
			
			// 在 startRace() 尾加：
			player.prevY = player.y;
			document.getElementById('lapHud').textContent = `LAP 0/${totalLaps}`;
			
        }
        
        function drawTrackFromWaypoints(ctx, track, scale = 1, offsetX = 0, offsetY = 0) {
            const wps = track.waypoints;
            if (!wps || !wps.length) return;
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(wps[0].x * scale + offsetX, wps[0].y * scale + offsetY);
            for (let i = 1; i < wps.length; i++) {
                ctx.lineTo(wps[i].x * scale + offsetX, wps[i].y * scale + offsetY);
            }
            ctx.lineTo(wps[0].x * scale + offsetX, wps[0].y * scale + offsetY);
            const roadWidth = 250;
            const edgeWidth = 10;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = roadWidth;
            ctx.stroke();
            ctx.strokeStyle = '#bbbbbb';
            ctx.lineWidth = roadWidth - edgeWidth * 2;
            ctx.stroke();
            ctx.restore();
        }
        
        function drawStartGrid(ctx, track, scale, offsetX, offsetY) {
            const grid = track.gridPositions;
            if (!grid || !grid.length || !track.start || !track.playerStart) return;
            ctx.save();
            // Start line
            const sx0 = track.start.x;
            const sy0 = track.start.y;
            const px0 = track.playerStart.x;
            const py0 = track.playerStart.y;
            let dirX = sx0 - px0;
            let dirY = sy0 - py0;
            const len = Math.hypot(dirX, dirY);
            dirX /= len;
            dirY /= len;
            const perpX = -dirY;
            const perpY = dirX;
            const sx = sx0 * scale - offsetX;
            const sy = sy0 * scale - offsetY;
            const lineLen = 650 * scale;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(sx - perpX * lineLen / 2, sy - perpY * lineLen / 2);
            ctx.lineTo(sx + perpX * lineLen / 2, sy + perpY * lineLen / 2);
            ctx.stroke();
            
            // Grid positions
            const boxL = 220;
            const boxW = 90;
            ctx.strokeStyle = 'rgba(255,255,255,0.9)';
            ctx.lineWidth = 4;
            ctx.fillStyle = '#ffffff';
            ctx.font = '26px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            grid.forEach((p, idx) => {
                const gx = p.x * scale - offsetX;
                const gy = p.y * scale - offsetY;
                const halfL = boxL / 2;
                const halfW = boxW / 2;
                const p1x = gx - halfL * dirX - halfW * perpX;
                const p1y = gy - halfL * dirY - halfW * perpY;
                const p2x = gx + halfL * dirX - halfW * perpX;
                const p2y = gy + halfL * dirY - halfW * perpY;
                const p3x = gx + halfL * dirX + halfW * perpX;
                const p3y = gy + halfL * dirY + halfW * perpY;
                const p4x = gx - halfL * dirX + halfW * perpX;
                const p4y = gy - halfL * dirY + halfW * perpY;
                ctx.beginPath();
                ctx.moveTo(p1x, p1y);
                ctx.lineTo(p2x, p2y);
                ctx.lineTo(p3x, p3y);
                ctx.lineTo(p4x, p4y);
                ctx.closePath();
                ctx.stroke();
                ctx.fillText(idx + 1, gx, gy);
            });
            ctx.restore();
        }
		
		function emitBoostForCar(car, isPlayer) {
			// 玩家：用按鍵判斷；AI：用速度判斷
			const boosting = isPlayer
				? (keys.ArrowUp || touch.up) && car.speed > 8
				: car.speed > 10; // AI 只要夠快就噴

			if (!boosting) return;

			// 生成火焰粒子
			for (let i = 0; i < 3; i++) { // 增加粒子數量到 3 讓效果更明顯
				boostParticles.push({
					x: car.x + Math.cos(car.angle + Math.PI) * 40,
					y: car.y + Math.sin(car.angle + Math.PI) * 40,
					vx: (Math.random() - 0.5) * 2,
					vy: (Math.random() - 0.5) * 2 + 1,
					life: 20, // 增加生命週期讓粒子飛更遠
					maxLife: 20
				});
			}
		}

        
		// 2. 視覺升級：改進的賽道繪製 (加入紅白路緣石)
		function drawCurrentTrackRoad(ctx, offsetX, offsetY) {
			const t = TRACKS[currentTrack];
			const wps = t.waypoints;
			if (!wps || !wps.length) return;

			ctx.save();
			ctx.lineJoin = 'round';
			// 修正 1：將 lineCap 從 'round' 改為 'butt'，防止在閉合點產生白色溢出
			ctx.lineCap = 'butt'; 

			// 建立路徑 (只做一次路徑，重複描邊)
			ctx.beginPath();
			ctx.moveTo(wps[0].x * SCALE - offsetX, wps[0].y * SCALE - offsetY);
			for (let i = 1; i < wps.length; i++) {
				ctx.lineTo(wps[i].x * SCALE - offsetX, wps[i].y * SCALE - offsetY);
			}
			ctx.closePath();
			
			// --- 修正 2：新增：第零層 (最底層) 黑色邊界 ---
			// 寬度設為 720，比路緣石 700 寬 20px，確保能包住所有溢出
			ctx.lineWidth = 720; 
			ctx.strokeStyle = '#000000'; // 純黑色，用於覆蓋任何白色邊緣
			ctx.stroke();

			// --- 第一層：路緣石底色 (紅色) ---
			ctx.lineWidth = 700; 
			ctx.strokeStyle = '#d32f2f'; // 賽車紅
			ctx.stroke(); 

			// --- 第二層：路緣石相間色 (白色虛線) ---
			ctx.lineWidth = 700;
			ctx.strokeStyle = '#ffffff';
			ctx.setLineDash([50, 50]); 
			ctx.lineDashOffset = -Date.now() / 20; 
			ctx.stroke(); 
			
			ctx.setLineDash([]); // 重置虛線

			// --- 第三層：柏油路面 (灰色) ---
			// 寬度 550，左右各留 75px 紅白路緣石
			ctx.lineWidth = 550;
			ctx.strokeStyle = '#555555'; // 深灰路面
			ctx.stroke(); 

			// --- 第四層：中央分隔線 ---
			ctx.lineWidth = 6;
			ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
			ctx.setLineDash([80, 100]);
			ctx.stroke();
			
			ctx.restore();
		}
        
        function loop() {
            // 使用沙地 Pattern 填滿背景，解決透明格問題
			if (sandPattern) {
				ctx.fillStyle = sandPattern;
				ctx.fillRect(0, 0, W, H);
			} else {
				ctx.fillStyle = '#C2B280'; // 後備顏色
				ctx.fillRect(0, 0, W, H);
			}
            if (!player) {
                requestAnimationFrame(loop);
                return;
            }
            
            const offsetX = player.x - W / 2;
            const offsetY = player.y - H / 2;
            
            ctx.drawImage(trackImg, -offsetX, -offsetY, TRACKS[currentTrack].originalWidth * SCALE, TRACKS[currentTrack].originalHeight * SCALE);
            
            // 賽道路徑
            drawCurrentTrackRoad(ctx, offsetX, offsetY);
            // drawTrackFromWaypoints(ctx, TRACKS[currentTrack], SCALE, offsetX, offsetY); // <-- **已移除重複呼叫**
            drawStartGrid(ctx, TRACKS[currentTrack], SCALE, offsetX, offsetY);
            
            // 繪製所有AI車輛
            allCars.forEach(car => {
                ctx.save();
                ctx.translate(car.x - offsetX, car.y - offsetY);
                ctx.rotate(car.angle + Math.PI / 2);
                if (car.img && car.img.complete) {
                    ctx.drawImage(car.img, -CARWIDTH / 2, -CARHEIGHT / 2, CARWIDTH, CARHEIGHT);
                }
                ctx.restore();
            });
            
            // AI邏輯更新 & 粒子生成
            if (gameState === 'racing' && !raceFinished) {
                allCars.forEach(followWaypoints);
				
                // **統一調用粒子生成函數**
				allCars.forEach(car => emitBoostForCar(car, false));
				emitBoostForCar(player, true);
							
            }
            
            // **已移除重複的玩家粒子生成程式碼塊**

            
            // 更新粒子
            boostParticles = boostParticles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                p.vy += 0.1; // 重力
                return p.life > 0;
            });
            
            // 繪製加速特效
            ctx.save();
            boostParticles.forEach(p => {
                const alpha = p.life / p.maxLife;
                const size = alpha * 8;
                const hue = 20 + alpha * 30;
                ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${alpha})`;
                ctx.beginPath();
                ctx.arc(p.x - offsetX, p.y - offsetY, size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();
            
            // 玩家車輛
            ctx.save();
            ctx.translate(W / 2, H / 2);
            ctx.rotate(player.angle + Math.PI / 2);
            if (player.img && player.img.complete) {
                ctx.drawImage(player.img, -CARWIDTH / 2, -CARHEIGHT / 2, CARWIDTH, CARHEIGHT);
            }
            ctx.restore();
            
            // 倒數計時
            if (gameState === 'countdown') {
                countdown -= 1 / 60;
                const el = document.getElementById('countdown');
                el.style.display = 'block';
                if (countdown > 4) el.textContent = '3';
                else if (countdown > 3) el.textContent = '2';
                else if (countdown > 2) el.textContent = '1';
                else if (countdown > 1) {
                    el.textContent = 'GO!';
                    el.style.color = '#0f0';
                } else {
                    el.style.display = 'none';
                    gameState = 'racing';
                }
            }
            
            // 玩家控制邏輯
            if (gameState === 'racing' && !raceFinished) {
                if (keys.ArrowLeft || touch.left) player.angle -= 0.038 * player.spec.handling;
                if (keys.ArrowRight || touch.right) player.angle += 0.038 * player.spec.handling;
                if (keys.ArrowUp || touch.up) {
                    player.speed += player.spec.acceleration * 0.03;
                } else if (keys.ArrowDown || touch.down) {
                    player.speed -= 1.8;
                } else {
                    player.speed *= 0.97;
                }
                player.speed = Math.max(-10, Math.min(player.speed, 22));
                player.x += Math.cos(player.angle) * player.speed;
                player.y += Math.sin(player.angle) * player.speed;
                
                // 碰撞檢測
                if (player.speed > 0) {
                    // 玩家與AI碰撞
                    for (let car of allCars) {
                        checkCollisions(player, car);
                    }
                    // AI間碰撞
                    for (let i = 0; i < allCars.length; i++) {
                        for (let j = i + 1; j < allCars.length; j++) {
                            checkCollisions(allCars[i], allCars[j]);
                        }
                    }
                }
                
				// 更新新的儀表板
				drawDashboard(player.speed);
				
                
				// 完賽檢測
				const startLineY = TRACKS[currentTrack].start.y * SCALE;

				// 只計由線後 → 線前（視乎方向，可視需要調轉 >= / <）
				if (player.prevY >= startLineY && player.y < startLineY && player.speed > 1) {
					lap++;

					if (lap === 1) {
						// 第一次過線：由 0 -> 1，只係開始計圈
					} else if (lap > totalLaps) {
						// 真正完賽
						raceFinished = true;
						gameState = 'finished';

						const sorted = [player, ...allCars].sort((a, b) => a.y - b.y);
						const pos = sorted.findIndex(c => c === player) + 1;
						document.getElementById('finalPos').textContent =
						  `FINAL POS #${pos}/${allCars.length + 1}`;
						document.getElementById('finishScreen').style.display = 'flex';
					}
				}

				// 無論有冇過線，都要更新 prevY
				player.prevY = player.y;

                
                // 更新HUD
                const sorted = [player, ...allCars].sort((a, b) => a.y - b.y);
                const pos = sorted.findIndex(c => c === player) + 1;
                document.getElementById('lapHud').textContent = `LAP ${lap}/${totalLaps}`;
                document.getElementById('posHud').textContent = `POS #${pos}/${allCars.length + 1}`;
                document.getElementById('speedHud').textContent = `${Math.round(Math.abs(player.speed) * 10)} kmh`;
            }
            
            requestAnimationFrame(loop);
        }
        
        // 事件監聽器
        window.addEventListener('load', () => {
			sandPattern = createSandPattern();
            // 生成棋盤格
            const checkered = document.getElementById('checkered');
            for (let i = 0; i < 60; i++) {
                const div = document.createElement('div');
                checkered.appendChild(div);
            }
            
            document.getElementById('startTitleBtn').onclick = () => {
                document.getElementById('titleScreen').style.display = 'none';
                document.getElementById('mainMenu').classList.add('active');
            };
            
            document.getElementById('champBtn').onclick = () => openTrackSelect('championship');
            document.getElementById('timeBtn').onclick = () => openTrackSelect('timeattack');
            
            document.getElementById('confirmTrackBtn').onclick = () => {
                document.getElementById('trackSelect').classList.remove('active');
                document.getElementById('carMenu').classList.add('active');
                buildCarList();
            };
            
            document.getElementById('confirmBtn').onclick = () => {
                document.getElementById('carMenu').classList.remove('active');
                playerCarImg.src = CARSPECS[selectedCar].image;
                playerCarImg.onload = startRace;
            };
            
            document.getElementById('backToMenuBtn').onclick = () => {
                document.getElementById('finishScreen').style.display = 'none';
                document.getElementById('mainMenu').classList.add('active');
                raceFinished = false;
            };
            
            // 觸控控制
            if ('ontouchstart' in window && navigator.maxTouchPoints > 0 && screen.width <= 1024) {
                document.getElementById('mobileControls').style.display = 'flex';
                ['Up', 'Down', 'Left', 'Right'].forEach(d => {
                    const b = document.getElementById(`btn${d}`);
                    b.addEventListener('touchstart', e => {
                        e.preventDefault();
                        touch[d.toLowerCase()] = true;
                    });
                    b.addEventListener('touchend', () => {
                        touch[d.toLowerCase()] = false;
                    });
                });
            }
            
            window.addEventListener('keydown', e => {
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                    keys[e.key] = true;
                }
            });
            window.addEventListener('keyup', e => {
                keys[e.key] = false;
            });
            
            loadTrack(0);
            requestAnimationFrame(loop);
        });
    </script>
</body>
</html>
