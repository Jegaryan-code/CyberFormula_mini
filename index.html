<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="utf-8">
    <title>Cyber Formula Mini Race</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&family=Orbitron:wght@900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: Rajdhani, sans-serif; color: #fff; }
        canvas { display: block; background: #000; margin: 20px auto; border: 3px solid #333; }
        
        #titleScreen { position: fixed; inset: 0; background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 999; }
        #titleScreen h1 { font-family: Orbitron, sans-serif; font-size: 110px; margin: 0 0 20px; letter-spacing: 12px; text-shadow: 0 0 40px #00ffff, 0 0 80px #00ffff; }
        #titleScreen h2 { font-size: 50px; margin: 10px 0; letter-spacing: 6px; text-shadow: 0 0 30px #fff; }
        
        #checkered { width: 600px; height: 140px; display: grid; grid-template-columns: repeat(15, 1fr); grid-template-rows: repeat(4, 1fr); border: 8px solid #fff; box-shadow: 0 0 50px rgba(255,255,255,0.8); margin: 50px 0; }
        #checkered div { width: 100%; height: 100%; background: #000; }
        #checkered div:nth-child(odd) { background: #fff; }
        #checkered div:nth-child(even) { background: #000; }
        
        #startTitleBtn { background: linear-gradient(45deg, #ff1b6b, #ff8c00); color: #fff; padding: 25px 90px; font-size: 48px; border: none; border-radius: 60px; cursor: pointer; transition: 0.4s; box-shadow: 0 15px 40px rgba(255,27,107,0.5); font-weight: 700; letter-spacing: 5px; }
        #startTitleBtn:hover { transform: scale(1.1); }
        
        #finishScreen { position: fixed; inset: 0; background: rgba(0,0,0,0.95); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 999; }
        #finishScreen h1 { font-family: Orbitron, sans-serif; font-size: 120px; color: #00ff41; text-shadow: 0 0 50px #00ff41; }
        #finalPos { font-size: 60px; margin: 30px 0; text-shadow: 0 0 30px #fff; }
        #backToMenuBtn { background: #00ff41; color: #000; padding: 25px 100px; font-size: 45px; border: none; border-radius: 60px; cursor: pointer; font-weight: 700; }
        
        #gameContainer { position: relative; width: 1000px; height: 1600px; margin: 20px auto; }
        canvas { z-index: 1; }
        #hud, #lapHud, #posHud, #speedHud, #countdown { z-index: 10; position: absolute; font-weight: bold; }
        #hud { top: 20px; left: 20px; background: rgba(0,0,0,0.7); padding: 10px 20px; border-radius: 12px; font: 22px Arial; }
        #lapHud { top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 12px 35px; border-radius: 12px; font: 32px Arial; }
        #posHud { top: 20px; right: 20px; background: rgba(0,0,0,0.7); padding: 10px 25px; border-radius: 12px; font: 26px Arial; }
        #speedHud { bottom: 240px; right: 30px; background: rgba(255,0,0,0.8); padding: 20px 40px; border-radius: 25px; font: 60px bold Arial; text-shadow: 0 0 20px #ff0000; }
        #countdown { top: 50%; left: 50%; transform: translate(-50%,-50%); font: 220px bold Arial; color: #ff0044; display: none; text-shadow: 0 0 60px #ff0000; }
        
        .menu { display: none; position: fixed; inset: 0; background: #000; flex-direction: column; align-items: center; overflow-y: auto; z-index: 99; padding: 40px 20px 120px; }
        .menu.active { display: flex; }
        .menu h1 { font-family: Orbitron, sans-serif; font-size: 70px; margin: 20px 0; text-shadow: 0 0 30px #00ffff; }
        
        .btn { background: linear-gradient(45deg, #667eea, #764ba2); padding: 18px 50px; margin: 15px; font-size: 36px; border: none; border-radius: 15px; cursor: pointer; width: 80%; max-width: 500px; transition: 0.3s; box-shadow: 0 10px 30px rgba(102,126,234,0.4); }
        .btn:hover { transform: scale(1.05); box-shadow: 0 15px 40px rgba(102,126,234,0.6); }
        
        /* Track Select */
        #trackSelect .track-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 25px; width: 100%; max-width: 1000px; margin: 30px 0; }
        .track-card { background: #111; padding: 20px; border-radius: 15px; cursor: pointer; transition: 0.3s; border: 4px solid transparent; text-align: center; }
        .track-card:hover { transform: scale(1.05); background: #222; }
        .track-card.selected { border: 4px solid #00ff41; background: #003300 !important; }
        .track-card img { width: 100%; max-height: 50vh; object-fit: contain; border-radius: 10px; }
        
        /* Car Select */
        #carMenu .container { max-width: 450px; width: 100%; padding: 20px 0; }
        #carList { display: grid; grid-template-columns: repeat(4, 1fr); gap: 25px; width: 100%; max-width: 450px; margin: 30px auto; }
        .card { background: #222; padding: 20px; border-radius: 15px; cursor: pointer; transition: 0.3s; text-align: center; border: 4px solid transparent; }
        .card:hover { transform: scale(1.05); background: #333; }
        .card.selected { border: 4px solid #0f0; background: #003300 !important; }
        .card img { width: 100%; max-height: 40vh; object-fit: contain; }
        
        /* Mobile Controls */
		#mobileControls {
		  position: fixed;
		  inset: 0;
		  pointer-events: none; /* 容器唔攔截，掣自己攔截 */
		  z-index: 999;
		}

		#moveVertical, #moveHorizontal {
		  position: absolute;
		  display: flex;
		  flex-direction: column;
		  gap: 18px;
		  pointer-events: auto;
		}

		#moveVertical {
		  left: 20px;
		  bottom: 100px;
		}

		#moveHorizontal {
		  right: 20px;
		  bottom: 80px;
		  flex-direction: row;
		}

		#mobileControls button {
		  width: 180px;
		  height: 180px;
		  border-radius: 0;          /* 用箭頭唔要圓形 */
		  border: 2px solid #fff;
		  background: rgba(0,0,0,0.6);
		  font-size: 60px;
		  color: #fff;
		  box-shadow: 0 8px 20px rgba(0,0,0,0.7);
		}

		#mobileControls button:active {
		  transform: scale(0.9);
		}

    </style>
</head>
<body>
    <div id="titleScreen">
        <h1>CYBER FORMULA</h1>
        <h2>MINI RACE</h2>
        <div id="checkered">
            <!-- Checkered pattern generated by JS -->
        </div>
        <button id="startTitleBtn">START</button>
    </div>
    
    <div id="finishScreen">
        <h1>FINISH!</h1>
        <p id="finalPos">FINAL POS #1</p>
        <button id="backToMenuBtn">BACK TO MENU</button>
    </div>
    
    <div id="mainMenu" class="menu">
        <h1>MODE SELECT</h1>
        <button class="btn" id="champBtn">CHAMPIONSHIP MODE</button>
        <button class="btn" id="timeBtn">TIME ATTACK</button>
    </div>
    
    <div id="trackSelect" class="menu">
        <h1>SELECT TRACK</h1>
        <div class="track-grid" id="trackGrid"></div>
        <button class="btn" id="confirmTrackBtn">CONFIRM TRACK</button>
    </div>
    
    <div id="carMenu" class="menu">
        <h1>SELECT CAR</h1>
        <div class="container">
            <div id="carList"></div>
        </div>
        <button class="btn" id="confirmBtn">CONFIRM CAR</button>
    </div>
    
    <div id="gameContainer">
        <canvas id="game" width="1000" height="1600"></canvas>
        <div id="hud"></div>
        <div id="lapHud">LAP 0/3</div>
        <div id="posHud">POS #1/11</div>
        <div id="speedHud">0 kmh</div>
        <div id="countdown"></div>
    </div>
    
	 <div id="mobileControls">
	  <div id="moveVertical">
		<button id="btnUp">↑</button>
		<button id="btnDown">↓</button>
	  </div>
	  <div id="moveHorizontal">
		<button id="btnLeft">←</button>
		<button id="btnRight">→</button>
	  </div>
	</div>


    <script src="cars.js"></script>
    <script src="track.js"></script>
    <script>
        const SCALE = 5;
        const CARWIDTH = 90;
        const CARHEIGHT = 150;
        
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        
        let player = null, allCars = [], gameState = 'title', mode = '', countdown = 0;
        let selectedCar = 0, playerCarImg = new Image(), trackImg = null;
        let keys = {}, touch = {}, lap = 1, totalLaps = 3, raceFinished = false, currentTrack = 0;
        let boostParticles = []; // 加速特效粒子
        
        // 碰撞檢測函數
		function checkCollisions(car1, car2) {
		  const dx = car2.x - car1.x;
		  const dy = car2.y - car1.y;
		  const dist = Math.hypot(dx, dy);
		  const minDist = (CARWIDTH + CARHEIGHT) / 3;

		  if (dist < minDist) {
			const push = (minDist - dist) * 0.4;
			const nx = dx / (dist || 1);
			const ny = dy / (dist || 1);

			car1.x -= nx * push;
			car1.y -= ny * push;
			car2.x += nx * push;
			car2.y += ny * push;

			// 只係略略衰減速度，唔交換
			car1.speed *= 0.9;
			car2.speed *= 0.9;
		  }
		}

        
        // 改進的AI超車邏輯
		function followWaypoints(car) {
		  if (car.waypointIndex == null) car.waypointIndex = 0;
		  const wp = TRACKS[currentTrack].waypoints;
		  if (!wp.length) return;

		  // 目標 waypoint
		  const baseTarget = wp[car.waypointIndex];
		  let tx = baseTarget.x * SCALE;
		  let ty = baseTarget.y * SCALE;

		  // 基於 waypoint 切線計算左右偏移 (簡化：用下一個點方向)
		  const nextIndex = (car.waypointIndex + 1) % wp.length;
		  const nx = wp[nextIndex].x * SCALE;
		  const ny = wp[nextIndex].y * SCALE;
		  let dirX = nx - tx;
		  let dirY = ny - ty;
		  const len = Math.hypot(dirX, dirY) || 1;
		  dirX /= len; dirY /= len;
		  // 法線向量 = 右邊
		  const nX = -dirY;
		  const nY = dirX;

		  // 基本線：自己的 laneOffset
		  const baseOffset = car.laneOffset || 0;
		  tx += nX * baseOffset;
		  ty += nY * baseOffset;

		  // 找出同一段路上、前面最近的車（包括玩家）
		  let frontCar = null;
		  let minDist = Infinity;
		  const candidates = [...allCars, player].filter(c => c !== car);
		  candidates.forEach(other => {
			const dx = other.x - car.x;
			const dy = other.y - car.y;
			const dist = Math.hypot(dx, dy);
			const rel = dx * dirX + dy * dirY; // 投影到前進方向
			if (rel > 0 && dist < 250 && dist < minDist) { // 前面250px內
			  minDist = dist;
			  frontCar = other;
			}
		  });

		  // 如果前面有車，嘗試向左／右多偏一條線
		  let dynamicOffset = 0;
		  if (frontCar) {
			const side = Math.sign((frontCar.x - car.x) * nX + (frontCar.y - car.y) * nY) || 1;
			dynamicOffset = side * 80; // 額外多偏 80px 去超車
		  }

		  const targetX = tx + nX * dynamicOffset;
		  const targetY = ty + nY * dynamicOffset;

		  const dx = targetX - car.x;
		  const dy = targetY - car.y;
		  const distToWp = Math.hypot(dx, dy);

		  if (distToWp < 500) {
			car.waypointIndex = (car.waypointIndex + 1) % wp.length;
		  }

		  const targetAngle = Math.atan2(dy, dx);
		  let angleDiff = targetAngle - car.angle;
		  // 正規化角度差到 [-PI, PI]
		  angleDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));
		  car.angle += angleDiff * 0.15; // 轉向平滑少少

		  // 速度控制：正常加速，前面塞車就減速
		  const maxSpeedBase = 23 + Math.random() * 4;
		  if (frontCar && minDist < 120) {
			car.speed += car.spec.acceleration * 0.03;
			car.speed = Math.min(car.speed, maxSpeedBase * 0.7); // 跟車
		  } else {
			car.speed += car.spec.acceleration * 0.06;
			car.speed = Math.min(car.speed, maxSpeedBase);       // 正常 / 超車
		  }
		  car.speed *= 0.985; // 空氣阻力

		  car.x += Math.cos(car.angle) * car.speed;
		  car.y += Math.sin(car.angle) * car.speed;
		}

        
        function loadTrack(i) {
            currentTrack = i;
            trackImg = new Image();
            trackImg.onload = () => {
                document.getElementById('hud').textContent = `TRACK: ${TRACKS[i].name}`;
            };
            trackImg.src = TRACKS[i].bgImage;
        }
        
        function openTrackSelect(m) {
            mode = m;
            document.getElementById('mainMenu').classList.remove('active');
            document.getElementById('trackSelect').classList.add('active');
            const grid = document.getElementById('trackGrid');
            grid.innerHTML = '';
            TRACKS.forEach((t, i) => {
                const d = document.createElement('div');
                d.className = `track-card ${i === currentTrack ? 'selected' : ''}`;
                d.innerHTML = `<img src="${t.bgImage}"><br>${t.name}`;
                d.onclick = () => {
                    currentTrack = i;
                    grid.querySelectorAll('.track-card').forEach(c => c.classList.remove('selected'));
                    d.classList.add('selected');
                    loadTrack(i);
                };
                grid.appendChild(d);
            });
        }
        
        function buildCarList() {
            const list = document.getElementById('carList');
            list.innerHTML = '';
            CARSPECS.forEach((c, i) => {
                const d = document.createElement('div');
                d.className = `card ${i === selectedCar ? 'selected' : ''}`;
                d.innerHTML = `<img src="${c.image}"><br>${c.image.split('.')[0]}`;
                d.onclick = () => {
                    selectedCar = i;
                    list.querySelectorAll('.card').forEach(x => x.classList.remove('selected'));
                    d.classList.add('selected');
                };
                list.appendChild(d);
            });
        }
        
        function startRace() {
            allCars = [];
            const t = TRACKS[currentTrack];
            if (mode === 'championship') {
                const a = CARSPECS.map((_, i) => i).filter(i => i !== selectedCar);
                const chosen = [];
                while (chosen.length < 10 && a.length > 0) {
                    chosen.push(a.splice(Math.floor(Math.random() * a.length), 1)[0]);
                }
                chosen.forEach((idx, i) => {
                    const img = new Image();
                    img.src = CARSPECS[idx].image;
                    const p = t.gridPositions[i];
                    allCars.push({
                        x: p.x * SCALE, y: p.y * SCALE, angle: t.playerStart.angle ,
                        speed: 0, spec: CARSPECS[idx], img: img, waypointIndex: 0,
						laneOffset: (i % 2 === 0 ? -60 : 60)  // 左右偏少少
                    });
                });
            }
            player = {
                x: t.playerStart.x * SCALE, y: t.playerStart.y * SCALE,
                angle: t.playerStart.angle , speed: 0,
                spec: CARSPECS[selectedCar], img: playerCarImg
            };
            countdown = 5;
            gameState = 'countdown';
            lap = 0;
            raceFinished = false;
			
			// 在 startRace() 尾加：
			player.prevY = player.y;
			
        }
        
        function drawTrackFromWaypoints(ctx, track, scale = 1, offsetX = 0, offsetY = 0) {
            const wps = track.waypoints;
            if (!wps || !wps.length) return;
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(wps[0].x * scale + offsetX, wps[0].y * scale + offsetY);
            for (let i = 1; i < wps.length; i++) {
                ctx.lineTo(wps[i].x * scale + offsetX, wps[i].y * scale + offsetY);
            }
            ctx.lineTo(wps[0].x * scale + offsetX, wps[0].y * scale + offsetY);
            const roadWidth = 550;
            const edgeWidth = 50;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = roadWidth;
            ctx.stroke();
            ctx.strokeStyle = '#bbbbbb';
            ctx.lineWidth = roadWidth - edgeWidth * 2;
            ctx.stroke();
            ctx.restore();
        }
        
        function drawStartGrid(ctx, track, scale, offsetX, offsetY) {
            const grid = track.gridPositions;
            if (!grid || !grid.length || !track.start || !track.playerStart) return;
            ctx.save();
            // Start line
            const sx0 = track.start.x;
            const sy0 = track.start.y;
            const px0 = track.playerStart.x;
            const py0 = track.playerStart.y;
            let dirX = sx0 - px0;
            let dirY = sy0 - py0;
            const len = Math.hypot(dirX, dirY);
            dirX /= len;
            dirY /= len;
            const perpX = -dirY;
            const perpY = dirX;
            const sx = sx0 * scale - offsetX;
            const sy = sy0 * scale - offsetY;
            const lineLen = 650 * scale;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(sx - perpX * lineLen / 2, sy - perpY * lineLen / 2);
            ctx.lineTo(sx + perpX * lineLen / 2, sy + perpY * lineLen / 2);
            ctx.stroke();
            
            // Grid positions
            const boxL = 220;
            const boxW = 90;
            ctx.strokeStyle = 'rgba(255,255,255,0.9)';
            ctx.lineWidth = 4;
            ctx.fillStyle = '#ffffff';
            ctx.font = '26px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            grid.forEach((p, idx) => {
                const gx = p.x * scale - offsetX;
                const gy = p.y * scale - offsetY;
                const halfL = boxL / 2;
                const halfW = boxW / 2;
                const p1x = gx - halfL * dirX - halfW * perpX;
                const p1y = gy - halfL * dirY - halfW * perpY;
                const p2x = gx + halfL * dirX - halfW * perpX;
                const p2y = gy + halfL * dirY - halfW * perpY;
                const p3x = gx + halfL * dirX + halfW * perpX;
                const p3y = gy + halfL * dirY + halfW * perpY;
                const p4x = gx - halfL * dirX + halfW * perpX;
                const p4y = gy - halfL * dirY + halfW * perpY;
                ctx.beginPath();
                ctx.moveTo(p1x, p1y);
                ctx.lineTo(p2x, p2y);
                ctx.lineTo(p3x, p3y);
                ctx.lineTo(p4x, p4y);
                ctx.closePath();
                ctx.stroke();
                ctx.fillText(idx + 1, gx, gy);
            });
            ctx.restore();
        }
		
		function emitBoostForCar(car, isPlayer) {
			// 玩家：用按鍵判斷；AI：用速度判斷
			const boosting = isPlayer
				? (keys.ArrowUp || touch.up) && car.speed > 8
				: car.speed > 10; // AI 只要夠快就噴

			if (!boosting) return;

			for (let i = 0; i < 2; i++) {
				boostParticles.push({
					x: car.x + Math.cos(car.angle + Math.PI) * 40,
					y: car.y + Math.sin(car.angle + Math.PI) * 40,
					vx: (Math.random() - 0.5) * 2,
					vy: (Math.random() - 0.5) * 2 + 1,
					life: 18,
					maxLife: 18
				});
			}
		}

        
        function drawCurrentTrackRoad(ctx, offsetX, offsetY) {
            const t = TRACKS[currentTrack];
            const scale = SCALE;
            drawTrackFromWaypoints(ctx, t, scale, -offsetX, -offsetY);
        }
        
        function loop() {
            ctx.clearRect(0, 0, W, H);
            if (!trackImg || !trackImg.complete || !player) {
                requestAnimationFrame(loop);
                return;
            }
            
            const offsetX = player.x - W / 2;
            const offsetY = player.y - H / 2;
            
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, 0, W, H);
            
            ctx.drawImage(trackImg, -offsetX, -offsetY, TRACKS[currentTrack].originalWidth * SCALE, TRACKS[currentTrack].originalHeight * SCALE);
            
            // 賽道路徑
            drawCurrentTrackRoad(ctx, offsetX, offsetY);
            drawTrackFromWaypoints(ctx, TRACKS[currentTrack], SCALE, offsetX, offsetY);
            drawStartGrid(ctx, TRACKS[currentTrack], SCALE, offsetX, offsetY);
            
            // 繪製所有AI車輛
            allCars.forEach(car => {
                ctx.save();
                ctx.translate(car.x - offsetX, car.y - offsetY);
                ctx.rotate(car.angle + Math.PI / 2);
                if (car.img && car.img.complete) {
                    ctx.drawImage(car.img, -CARWIDTH / 2, -CARHEIGHT / 2, CARWIDTH, CARHEIGHT);
                }
                ctx.restore();
            });
            
            // AI邏輯更新
            if (gameState === 'racing' && !raceFinished) {
                allCars.forEach(followWaypoints);
				allCars.forEach(car => emitBoostForCar(car, false));
				// 為玩家產生粒子
				emitBoostForCar(player, true);
							
            }
            
            // 加速特效粒子更新
            if (gameState === 'racing' && !raceFinished && keys.ArrowUp && player.speed > 8) {
                // 生成火焰粒子
                for (let i = 0; i < 3; i++) {
                    boostParticles.push({
                        x: player.x + Math.cos(player.angle + Math.PI) * 40,
                        y: player.y + Math.sin(player.angle + Math.PI) * 40,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2 + 1,
                        life: 20,
                        maxLife: 20
                    });
                }
            }
            
            // 更新粒子
            boostParticles = boostParticles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                p.vy += 0.1; // 重力
                return p.life > 0;
            });
            
            // 繪製加速特效
            ctx.save();
            boostParticles.forEach(p => {
                const alpha = p.life / p.maxLife;
                const size = alpha * 8;
                const hue = 20 + alpha * 30;
                ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${alpha})`;
                ctx.beginPath();
                ctx.arc(p.x - offsetX, p.y - offsetY, size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();
            
            // 玩家車輛
            ctx.save();
            ctx.translate(W / 2, H / 2);
            ctx.rotate(player.angle + Math.PI / 2);
            if (player.img && player.img.complete) {
                ctx.drawImage(player.img, -CARWIDTH / 2, -CARHEIGHT / 2, CARWIDTH, CARHEIGHT);
            }
            ctx.restore();
            
            // 倒數計時
            if (gameState === 'countdown') {
                countdown -= 1 / 60;
                const el = document.getElementById('countdown');
                el.style.display = 'block';
                if (countdown > 4) el.textContent = '3';
                else if (countdown > 3) el.textContent = '2';
                else if (countdown > 2) el.textContent = '1';
                else if (countdown > 1) {
                    el.textContent = 'GO!';
                    el.style.color = '#0f0';
                } else {
                    el.style.display = 'none';
                    gameState = 'racing';
                }
            }
            
            // 玩家控制邏輯
            if (gameState === 'racing' && !raceFinished) {
                if (keys.ArrowLeft || touch.left) player.angle -= 0.038 * player.spec.handling;
                if (keys.ArrowRight || touch.right) player.angle += 0.038 * player.spec.handling;
                if (keys.ArrowUp || touch.up) {
                    player.speed += player.spec.acceleration * 0.03;
                } else if (keys.ArrowDown || touch.down) {
                    player.speed -= 1.8;
                } else {
                    player.speed *= 0.97;
                }
                player.speed = Math.max(-10, Math.min(player.speed, 22));
                player.x += Math.cos(player.angle) * player.speed;
                player.y += Math.sin(player.angle) * player.speed;
                
                // 碰撞檢測
                if (player.speed > 0) {
                    // 玩家與AI碰撞
                    for (let car of allCars) {
                        checkCollisions(player, car);
                    }
                    // AI間碰撞
                    for (let i = 0; i < allCars.length; i++) {
                        for (let j = i + 1; j < allCars.length; j++) {
                            checkCollisions(allCars[i], allCars[j]);
                        }
                    }
                }
                
                // 完賽檢測
				const startLineY = TRACKS[currentTrack].start.y * SCALE;

				if (player.prevY >= startLineY && player.y < startLineY && player.speed > 10) {
					lap++;
					if (lap > totalLaps) {
						// finish
					}
				}
				player.prevY = player.y;
                
                // 更新HUD
                const sorted = [player, ...allCars].sort((a, b) => a.y - b.y);
                const pos = sorted.findIndex(c => c === player) + 1;
                document.getElementById('lapHud').textContent = `LAP ${lap}/${totalLaps}`;
                document.getElementById('posHud').textContent = `POS #${pos}/${allCars.length + 1}`;
                document.getElementById('speedHud').textContent = `${Math.round(Math.abs(player.speed) * 10)} kmh`;
            }
            
            requestAnimationFrame(loop);
        }
        
        // 事件監聽器
        window.addEventListener('load', () => {
            // 生成棋盤格
            const checkered = document.getElementById('checkered');
            for (let i = 0; i < 60; i++) {
                const div = document.createElement('div');
                checkered.appendChild(div);
            }
            
            document.getElementById('startTitleBtn').onclick = () => {
                document.getElementById('titleScreen').style.display = 'none';
                document.getElementById('mainMenu').classList.add('active');
            };
            
            document.getElementById('champBtn').onclick = () => openTrackSelect('championship');
            document.getElementById('timeBtn').onclick = () => openTrackSelect('timeattack');
            
            document.getElementById('confirmTrackBtn').onclick = () => {
                document.getElementById('trackSelect').classList.remove('active');
                document.getElementById('carMenu').classList.add('active');
                buildCarList();
            };
            
            document.getElementById('confirmBtn').onclick = () => {
                document.getElementById('carMenu').classList.remove('active');
                playerCarImg.src = CARSPECS[selectedCar].image;
                playerCarImg.onload = startRace;
            };
            
            document.getElementById('backToMenuBtn').onclick = () => {
                document.getElementById('finishScreen').style.display = 'none';
                document.getElementById('mainMenu').classList.add('active');
                raceFinished = false;
            };
            
            // 觸控控制
            if ('ontouchstart' in window && navigator.maxTouchPoints > 0 && screen.width <= 1024) {
                document.getElementById('mobileControls').style.display = 'flex';
                ['Up', 'Down', 'Left', 'Right'].forEach(d => {
                    const b = document.getElementById(`btn${d}`);
                    b.addEventListener('touchstart', e => {
                        e.preventDefault();
                        touch[d.toLowerCase()] = true;
                    });
                    b.addEventListener('touchend', () => {
                        touch[d.toLowerCase()] = false;
                    });
                });
            }
            
            window.addEventListener('keydown', e => {
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                    keys[e.key] = true;
                }
            });
            window.addEventListener('keyup', e => {
                keys[e.key] = false;
            });
            
            loadTrack(0);
            requestAnimationFrame(loop);
        });
    </script>
</body>
</html>
